// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod rman {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum BundleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Bundle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Bundle<'a> {
  type Inner = Bundle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Bundle<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CHUNKS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Bundle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BundleArgs<'args>
  ) -> flatbuffers::WIPOffset<Bundle<'bldr>> {
    let mut builder = BundleBuilder::new(_fbb);
    builder.add_id(args.id);
    if let Some(x) = args.chunks { builder.add_chunks(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Bundle::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn chunks(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Chunk<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Chunk>>>>(Bundle::VT_CHUNKS, None)}
  }
}

impl flatbuffers::Verifiable for Bundle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Chunk>>>>("chunks", Self::VT_CHUNKS, false)?
     .finish();
    Ok(())
  }
}
pub struct BundleArgs<'a> {
    pub id: i64,
    pub chunks: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Chunk<'a>>>>>,
}
impl<'a> Default for BundleArgs<'a> {
  #[inline]
  fn default() -> Self {
    BundleArgs {
      id: 0,
      chunks: None,
    }
  }
}

pub struct BundleBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BundleBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: i64) {
    self.fbb_.push_slot::<i64>(Bundle::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_chunks(&mut self, chunks: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Chunk<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Bundle::VT_CHUNKS, chunks);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BundleBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BundleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Bundle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Bundle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Bundle");
      ds.field("id", &self.id());
      ds.field("chunks", &self.chunks());
      ds.finish()
  }
}
pub enum ChunkOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Chunk<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Chunk<'a> {
  type Inner = Chunk<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Chunk<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_COMPRESSED_SIZE: flatbuffers::VOffsetT = 6;
  pub const VT_UNCOMPRESSED_SIZE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Chunk { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ChunkArgs
  ) -> flatbuffers::WIPOffset<Chunk<'bldr>> {
    let mut builder = ChunkBuilder::new(_fbb);
    builder.add_id(args.id);
    builder.add_uncompressed_size(args.uncompressed_size);
    builder.add_compressed_size(args.compressed_size);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Chunk::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn compressed_size(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Chunk::VT_COMPRESSED_SIZE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn uncompressed_size(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Chunk::VT_UNCOMPRESSED_SIZE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Chunk<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("id", Self::VT_ID, false)?
     .visit_field::<u32>("compressed_size", Self::VT_COMPRESSED_SIZE, false)?
     .visit_field::<u32>("uncompressed_size", Self::VT_UNCOMPRESSED_SIZE, false)?
     .finish();
    Ok(())
  }
}
pub struct ChunkArgs {
    pub id: i64,
    pub compressed_size: u32,
    pub uncompressed_size: u32,
}
impl<'a> Default for ChunkArgs {
  #[inline]
  fn default() -> Self {
    ChunkArgs {
      id: 0,
      compressed_size: 0,
      uncompressed_size: 0,
    }
  }
}

pub struct ChunkBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ChunkBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: i64) {
    self.fbb_.push_slot::<i64>(Chunk::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_compressed_size(&mut self, compressed_size: u32) {
    self.fbb_.push_slot::<u32>(Chunk::VT_COMPRESSED_SIZE, compressed_size, 0);
  }
  #[inline]
  pub fn add_uncompressed_size(&mut self, uncompressed_size: u32) {
    self.fbb_.push_slot::<u32>(Chunk::VT_UNCOMPRESSED_SIZE, uncompressed_size, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ChunkBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ChunkBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Chunk<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Chunk<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Chunk");
      ds.field("id", &self.id());
      ds.field("compressed_size", &self.compressed_size());
      ds.field("uncompressed_size", &self.uncompressed_size());
      ds.finish()
  }
}
pub enum DirectoryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Directory<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Directory<'a> {
  type Inner = Directory<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Directory<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_PARENT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_NAME: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Directory { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DirectoryArgs<'args>
  ) -> flatbuffers::WIPOffset<Directory<'bldr>> {
    let mut builder = DirectoryBuilder::new(_fbb);
    builder.add_parent_id(args.parent_id);
    builder.add_id(args.id);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Directory::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn parent_id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Directory::VT_PARENT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Directory::VT_NAME, None)}
  }
}

impl flatbuffers::Verifiable for Directory<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("id", Self::VT_ID, false)?
     .visit_field::<i64>("parent_id", Self::VT_PARENT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct DirectoryArgs<'a> {
    pub id: i64,
    pub parent_id: i64,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DirectoryArgs<'a> {
  #[inline]
  fn default() -> Self {
    DirectoryArgs {
      id: 0,
      parent_id: 0,
      name: None,
    }
  }
}

pub struct DirectoryBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DirectoryBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: i64) {
    self.fbb_.push_slot::<i64>(Directory::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_parent_id(&mut self, parent_id: i64) {
    self.fbb_.push_slot::<i64>(Directory::VT_PARENT_ID, parent_id, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Directory::VT_NAME, name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DirectoryBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DirectoryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Directory<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Directory<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Directory");
      ds.field("id", &self.id());
      ds.field("parent_id", &self.parent_id());
      ds.field("name", &self.name());
      ds.finish()
  }
}
pub enum FileOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct File<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for File<'a> {
  type Inner = File<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> File<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_DIRECTORY_ID: flatbuffers::VOffsetT = 6;
  pub const VT_SIZE_: flatbuffers::VOffsetT = 8;
  pub const VT_NAME: flatbuffers::VOffsetT = 10;
  pub const VT_TAG_BITMASK: flatbuffers::VOffsetT = 12;
  pub const VT_UNK5: flatbuffers::VOffsetT = 14;
  pub const VT_UNK6: flatbuffers::VOffsetT = 16;
  pub const VT_CHUNK_IDS: flatbuffers::VOffsetT = 18;
  pub const VT_UNK8: flatbuffers::VOffsetT = 20;
  pub const VT_SYMLINK: flatbuffers::VOffsetT = 22;
  pub const VT_UNK10: flatbuffers::VOffsetT = 24;
  pub const VT_CHUNKING_PARAM_ID: flatbuffers::VOffsetT = 26;
  pub const VT_PERMISSIONS: flatbuffers::VOffsetT = 28;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    File { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args FileArgs<'args>
  ) -> flatbuffers::WIPOffset<File<'bldr>> {
    let mut builder = FileBuilder::new(_fbb);
    builder.add_tag_bitmask(args.tag_bitmask);
    builder.add_directory_id(args.directory_id);
    builder.add_id(args.id);
    if let Some(x) = args.symlink { builder.add_symlink(x); }
    if let Some(x) = args.chunk_ids { builder.add_chunk_ids(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_size_(args.size_);
    builder.add_unk10(args.unk10);
    builder.add_permissions(args.permissions);
    builder.add_chunking_param_id(args.chunking_param_id);
    builder.add_unk8(args.unk8);
    builder.add_unk6(args.unk6);
    builder.add_unk5(args.unk5);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(File::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn directory_id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(File::VT_DIRECTORY_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn size_(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(File::VT_SIZE_, Some(0)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(File::VT_NAME, None)}
  }
  #[inline]
  pub fn tag_bitmask(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(File::VT_TAG_BITMASK, Some(0)).unwrap()}
  }
  #[inline]
  pub fn unk5(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(File::VT_UNK5, Some(0)).unwrap()}
  }
  #[inline]
  pub fn unk6(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(File::VT_UNK6, Some(0)).unwrap()}
  }
  #[inline]
  pub fn chunk_ids(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(File::VT_CHUNK_IDS, None)}
  }
  #[inline]
  pub fn unk8(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(File::VT_UNK8, Some(0)).unwrap()}
  }
  #[inline]
  pub fn symlink(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(File::VT_SYMLINK, None)}
  }
  #[inline]
  pub fn unk10(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(File::VT_UNK10, Some(0)).unwrap()}
  }
  #[inline]
  pub fn chunking_param_id(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(File::VT_CHUNKING_PARAM_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn permissions(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(File::VT_PERMISSIONS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for File<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("id", Self::VT_ID, false)?
     .visit_field::<i64>("directory_id", Self::VT_DIRECTORY_ID, false)?
     .visit_field::<u32>("size_", Self::VT_SIZE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<u64>("tag_bitmask", Self::VT_TAG_BITMASK, false)?
     .visit_field::<u8>("unk5", Self::VT_UNK5, false)?
     .visit_field::<u8>("unk6", Self::VT_UNK6, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("chunk_ids", Self::VT_CHUNK_IDS, false)?
     .visit_field::<u8>("unk8", Self::VT_UNK8, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("symlink", Self::VT_SYMLINK, false)?
     .visit_field::<u16>("unk10", Self::VT_UNK10, false)?
     .visit_field::<u8>("chunking_param_id", Self::VT_CHUNKING_PARAM_ID, false)?
     .visit_field::<u8>("permissions", Self::VT_PERMISSIONS, false)?
     .finish();
    Ok(())
  }
}
pub struct FileArgs<'a> {
    pub id: i64,
    pub directory_id: i64,
    pub size_: u32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tag_bitmask: u64,
    pub unk5: u8,
    pub unk6: u8,
    pub chunk_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub unk8: u8,
    pub symlink: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unk10: u16,
    pub chunking_param_id: u8,
    pub permissions: u8,
}
impl<'a> Default for FileArgs<'a> {
  #[inline]
  fn default() -> Self {
    FileArgs {
      id: 0,
      directory_id: 0,
      size_: 0,
      name: None,
      tag_bitmask: 0,
      unk5: 0,
      unk6: 0,
      chunk_ids: None,
      unk8: 0,
      symlink: None,
      unk10: 0,
      chunking_param_id: 0,
      permissions: 0,
    }
  }
}

pub struct FileBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FileBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: i64) {
    self.fbb_.push_slot::<i64>(File::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_directory_id(&mut self, directory_id: i64) {
    self.fbb_.push_slot::<i64>(File::VT_DIRECTORY_ID, directory_id, 0);
  }
  #[inline]
  pub fn add_size_(&mut self, size_: u32) {
    self.fbb_.push_slot::<u32>(File::VT_SIZE_, size_, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(File::VT_NAME, name);
  }
  #[inline]
  pub fn add_tag_bitmask(&mut self, tag_bitmask: u64) {
    self.fbb_.push_slot::<u64>(File::VT_TAG_BITMASK, tag_bitmask, 0);
  }
  #[inline]
  pub fn add_unk5(&mut self, unk5: u8) {
    self.fbb_.push_slot::<u8>(File::VT_UNK5, unk5, 0);
  }
  #[inline]
  pub fn add_unk6(&mut self, unk6: u8) {
    self.fbb_.push_slot::<u8>(File::VT_UNK6, unk6, 0);
  }
  #[inline]
  pub fn add_chunk_ids(&mut self, chunk_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(File::VT_CHUNK_IDS, chunk_ids);
  }
  #[inline]
  pub fn add_unk8(&mut self, unk8: u8) {
    self.fbb_.push_slot::<u8>(File::VT_UNK8, unk8, 0);
  }
  #[inline]
  pub fn add_symlink(&mut self, symlink: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(File::VT_SYMLINK, symlink);
  }
  #[inline]
  pub fn add_unk10(&mut self, unk10: u16) {
    self.fbb_.push_slot::<u16>(File::VT_UNK10, unk10, 0);
  }
  #[inline]
  pub fn add_chunking_param_id(&mut self, chunking_param_id: u8) {
    self.fbb_.push_slot::<u8>(File::VT_CHUNKING_PARAM_ID, chunking_param_id, 0);
  }
  #[inline]
  pub fn add_permissions(&mut self, permissions: u8) {
    self.fbb_.push_slot::<u8>(File::VT_PERMISSIONS, permissions, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FileBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FileBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<File<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for File<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("File");
      ds.field("id", &self.id());
      ds.field("directory_id", &self.directory_id());
      ds.field("size_", &self.size_());
      ds.field("name", &self.name());
      ds.field("tag_bitmask", &self.tag_bitmask());
      ds.field("unk5", &self.unk5());
      ds.field("unk6", &self.unk6());
      ds.field("chunk_ids", &self.chunk_ids());
      ds.field("unk8", &self.unk8());
      ds.field("symlink", &self.symlink());
      ds.field("unk10", &self.unk10());
      ds.field("chunking_param_id", &self.chunking_param_id());
      ds.field("permissions", &self.permissions());
      ds.finish()
  }
}
pub enum KeyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Key<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Key<'a> {
  type Inner = Key<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Key<'a> {
  pub const VT_UNK0: flatbuffers::VOffsetT = 4;
  pub const VT_UNK1: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Key { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args KeyArgs
  ) -> flatbuffers::WIPOffset<Key<'bldr>> {
    let mut builder = KeyBuilder::new(_fbb);
    builder.add_unk1(args.unk1);
    builder.add_unk0(args.unk0);
    builder.finish()
  }


  #[inline]
  pub fn unk0(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(Key::VT_UNK0, Some(0)).unwrap()}
  }
  #[inline]
  pub fn unk1(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Key::VT_UNK1, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Key<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("unk0", Self::VT_UNK0, false)?
     .visit_field::<u32>("unk1", Self::VT_UNK1, false)?
     .finish();
    Ok(())
  }
}
pub struct KeyArgs {
    pub unk0: u16,
    pub unk1: u32,
}
impl<'a> Default for KeyArgs {
  #[inline]
  fn default() -> Self {
    KeyArgs {
      unk0: 0,
      unk1: 0,
    }
  }
}

pub struct KeyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> KeyBuilder<'a, 'b> {
  #[inline]
  pub fn add_unk0(&mut self, unk0: u16) {
    self.fbb_.push_slot::<u16>(Key::VT_UNK0, unk0, 0);
  }
  #[inline]
  pub fn add_unk1(&mut self, unk1: u32) {
    self.fbb_.push_slot::<u32>(Key::VT_UNK1, unk1, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> KeyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    KeyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Key<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Key<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Key");
      ds.field("unk0", &self.unk0());
      ds.field("unk1", &self.unk1());
      ds.finish()
  }
}
pub enum TagOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Tag<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Tag<'a> {
  type Inner = Tag<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Tag<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Tag { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TagArgs<'args>
  ) -> flatbuffers::WIPOffset<Tag<'bldr>> {
    let mut builder = TagBuilder::new(_fbb);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_id(args.id);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Tag::VT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Tag::VT_NAME, None)}
  }
}

impl flatbuffers::Verifiable for Tag<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct TagArgs<'a> {
    pub id: u8,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for TagArgs<'a> {
  #[inline]
  fn default() -> Self {
    TagArgs {
      id: 0,
      name: None,
    }
  }
}

pub struct TagBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TagBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u8) {
    self.fbb_.push_slot::<u8>(Tag::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tag::VT_NAME, name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TagBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TagBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Tag<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Tag<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Tag");
      ds.field("id", &self.id());
      ds.field("name", &self.name());
      ds.finish()
  }
}
pub enum ManifestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Manifest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Manifest<'a> {
  type Inner = Manifest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Manifest<'a> {
  pub const VT_BUNDLES: flatbuffers::VOffsetT = 4;
  pub const VT_TAGS: flatbuffers::VOffsetT = 6;
  pub const VT_FILES: flatbuffers::VOffsetT = 8;
  pub const VT_DIRECTORIES: flatbuffers::VOffsetT = 10;
  pub const VT_KEYS: flatbuffers::VOffsetT = 12;
  pub const VT_CHUNKING_PARAMS: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Manifest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ManifestArgs<'args>
  ) -> flatbuffers::WIPOffset<Manifest<'bldr>> {
    let mut builder = ManifestBuilder::new(_fbb);
    if let Some(x) = args.chunking_params { builder.add_chunking_params(x); }
    if let Some(x) = args.keys { builder.add_keys(x); }
    if let Some(x) = args.directories { builder.add_directories(x); }
    if let Some(x) = args.files { builder.add_files(x); }
    if let Some(x) = args.tags { builder.add_tags(x); }
    if let Some(x) = args.bundles { builder.add_bundles(x); }
    builder.finish()
  }


  #[inline]
  pub fn bundles(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Bundle<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Bundle>>>>(Manifest::VT_BUNDLES, None)}
  }
  #[inline]
  pub fn tags(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Tag<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Tag>>>>(Manifest::VT_TAGS, None)}
  }
  #[inline]
  pub fn files(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<File<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<File>>>>(Manifest::VT_FILES, None)}
  }
  #[inline]
  pub fn directories(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Directory<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Directory>>>>(Manifest::VT_DIRECTORIES, None)}
  }
  #[inline]
  pub fn keys(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Key<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Key>>>>(Manifest::VT_KEYS, None)}
  }
  #[inline]
  pub fn chunking_params(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ChunkingParam<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ChunkingParam>>>>(Manifest::VT_CHUNKING_PARAMS, None)}
  }
}

impl flatbuffers::Verifiable for Manifest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Bundle>>>>("bundles", Self::VT_BUNDLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Tag>>>>("tags", Self::VT_TAGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<File>>>>("files", Self::VT_FILES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Directory>>>>("directories", Self::VT_DIRECTORIES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Key>>>>("keys", Self::VT_KEYS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ChunkingParam>>>>("chunking_params", Self::VT_CHUNKING_PARAMS, false)?
     .finish();
    Ok(())
  }
}
pub struct ManifestArgs<'a> {
    pub bundles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Bundle<'a>>>>>,
    pub tags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Tag<'a>>>>>,
    pub files: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<File<'a>>>>>,
    pub directories: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Directory<'a>>>>>,
    pub keys: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Key<'a>>>>>,
    pub chunking_params: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ChunkingParam<'a>>>>>,
}
impl<'a> Default for ManifestArgs<'a> {
  #[inline]
  fn default() -> Self {
    ManifestArgs {
      bundles: None,
      tags: None,
      files: None,
      directories: None,
      keys: None,
      chunking_params: None,
    }
  }
}

pub struct ManifestBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ManifestBuilder<'a, 'b> {
  #[inline]
  pub fn add_bundles(&mut self, bundles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Bundle<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Manifest::VT_BUNDLES, bundles);
  }
  #[inline]
  pub fn add_tags(&mut self, tags: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Tag<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Manifest::VT_TAGS, tags);
  }
  #[inline]
  pub fn add_files(&mut self, files: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<File<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Manifest::VT_FILES, files);
  }
  #[inline]
  pub fn add_directories(&mut self, directories: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Directory<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Manifest::VT_DIRECTORIES, directories);
  }
  #[inline]
  pub fn add_keys(&mut self, keys: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Key<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Manifest::VT_KEYS, keys);
  }
  #[inline]
  pub fn add_chunking_params(&mut self, chunking_params: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ChunkingParam<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Manifest::VT_CHUNKING_PARAMS, chunking_params);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ManifestBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ManifestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Manifest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Manifest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Manifest");
      ds.field("bundles", &self.bundles());
      ds.field("tags", &self.tags());
      ds.field("files", &self.files());
      ds.field("directories", &self.directories());
      ds.field("keys", &self.keys());
      ds.field("chunking_params", &self.chunking_params());
      ds.finish()
  }
}
pub enum ChunkingParamOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ChunkingParam<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ChunkingParam<'a> {
  type Inner = ChunkingParam<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ChunkingParam<'a> {
  pub const VT_UNK0: flatbuffers::VOffsetT = 4;
  pub const VT_CHUNKING_VERSION: flatbuffers::VOffsetT = 6;
  pub const VT_MIN_CHUNK_SIZE: flatbuffers::VOffsetT = 8;
  pub const VT_CHUNK_SIZE: flatbuffers::VOffsetT = 10;
  pub const VT_MAX_CHUNK_SIZE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ChunkingParam { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ChunkingParamArgs
  ) -> flatbuffers::WIPOffset<ChunkingParam<'bldr>> {
    let mut builder = ChunkingParamBuilder::new(_fbb);
    builder.add_max_chunk_size(args.max_chunk_size);
    builder.add_chunk_size(args.chunk_size);
    builder.add_min_chunk_size(args.min_chunk_size);
    builder.add_unk0(args.unk0);
    builder.add_chunking_version(args.chunking_version);
    builder.finish()
  }


  #[inline]
  pub fn unk0(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(ChunkingParam::VT_UNK0, Some(0)).unwrap()}
  }
  #[inline]
  pub fn chunking_version(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ChunkingParam::VT_CHUNKING_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn min_chunk_size(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ChunkingParam::VT_MIN_CHUNK_SIZE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn chunk_size(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ChunkingParam::VT_CHUNK_SIZE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn max_chunk_size(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ChunkingParam::VT_MAX_CHUNK_SIZE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ChunkingParam<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("unk0", Self::VT_UNK0, false)?
     .visit_field::<u8>("chunking_version", Self::VT_CHUNKING_VERSION, false)?
     .visit_field::<u32>("min_chunk_size", Self::VT_MIN_CHUNK_SIZE, false)?
     .visit_field::<u32>("chunk_size", Self::VT_CHUNK_SIZE, false)?
     .visit_field::<u32>("max_chunk_size", Self::VT_MAX_CHUNK_SIZE, false)?
     .finish();
    Ok(())
  }
}
pub struct ChunkingParamArgs {
    pub unk0: u16,
    pub chunking_version: u8,
    pub min_chunk_size: u32,
    pub chunk_size: u32,
    pub max_chunk_size: u32,
}
impl<'a> Default for ChunkingParamArgs {
  #[inline]
  fn default() -> Self {
    ChunkingParamArgs {
      unk0: 0,
      chunking_version: 0,
      min_chunk_size: 0,
      chunk_size: 0,
      max_chunk_size: 0,
    }
  }
}

pub struct ChunkingParamBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ChunkingParamBuilder<'a, 'b> {
  #[inline]
  pub fn add_unk0(&mut self, unk0: u16) {
    self.fbb_.push_slot::<u16>(ChunkingParam::VT_UNK0, unk0, 0);
  }
  #[inline]
  pub fn add_chunking_version(&mut self, chunking_version: u8) {
    self.fbb_.push_slot::<u8>(ChunkingParam::VT_CHUNKING_VERSION, chunking_version, 0);
  }
  #[inline]
  pub fn add_min_chunk_size(&mut self, min_chunk_size: u32) {
    self.fbb_.push_slot::<u32>(ChunkingParam::VT_MIN_CHUNK_SIZE, min_chunk_size, 0);
  }
  #[inline]
  pub fn add_chunk_size(&mut self, chunk_size: u32) {
    self.fbb_.push_slot::<u32>(ChunkingParam::VT_CHUNK_SIZE, chunk_size, 0);
  }
  #[inline]
  pub fn add_max_chunk_size(&mut self, max_chunk_size: u32) {
    self.fbb_.push_slot::<u32>(ChunkingParam::VT_MAX_CHUNK_SIZE, max_chunk_size, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ChunkingParamBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ChunkingParamBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ChunkingParam<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ChunkingParam<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ChunkingParam");
      ds.field("unk0", &self.unk0());
      ds.field("chunking_version", &self.chunking_version());
      ds.field("min_chunk_size", &self.min_chunk_size());
      ds.field("chunk_size", &self.chunk_size());
      ds.field("max_chunk_size", &self.max_chunk_size());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Manifest`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_manifest_unchecked`.
pub fn root_as_manifest(buf: &[u8]) -> Result<Manifest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Manifest>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Manifest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_manifest_unchecked`.
pub fn size_prefixed_root_as_manifest(buf: &[u8]) -> Result<Manifest, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Manifest>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Manifest` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_manifest_unchecked`.
pub fn root_as_manifest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Manifest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Manifest<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Manifest` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_manifest_unchecked`.
pub fn size_prefixed_root_as_manifest_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Manifest<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Manifest<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Manifest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Manifest`.
pub unsafe fn root_as_manifest_unchecked(buf: &[u8]) -> Manifest {
  flatbuffers::root_unchecked::<Manifest>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Manifest and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Manifest`.
pub unsafe fn size_prefixed_root_as_manifest_unchecked(buf: &[u8]) -> Manifest {
  flatbuffers::size_prefixed_root_unchecked::<Manifest>(buf)
}
#[inline]
pub fn finish_manifest_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Manifest<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_manifest_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Manifest<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod rman

